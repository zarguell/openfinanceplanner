---
phase: 14-core-financial-engine
plan: 03
type: execute
wave: 1
depends_on:
  - 14-02
files_modified:
  - src/core/projection/index.test.ts
  - src/core/types/index.test.ts
  - package.json
  - vitest.config.ts
autonomous: true

must_haves:
  truths:
    - 'All engine functions have comprehensive unit tests covering edge cases'
    - 'Test suite includes invalid inputs, boundary conditions, floating-point precision tests'
    - 'TDD workflow demonstrated in git history (failing tests before implementation)'
    - 'Test coverage meets threshold for financial calculations (edge cases + happy paths)'
    - 'Tests run in isolation (node environment, not jsdom)'
    - 'Documentation explains TDD red-green-refactor cycle used'
  artifacts:
    - path: 'src/core/projection/index.test.ts'
      provides: 'Comprehensive test coverage for calculateProjection function'
      contains: ['describe', 'it', 'test.each', 'expect', 'toBeCloseTo', 'edge cases']
    - path: 'src/core/types/index.test.ts'
      provides: 'Type validation tests with readonly enforcement'
      contains: ['@ts-expect-error', 'compile-time validation']
    - path: '14-03-SUMMARY.md'
      provides: 'Test coverage report and TDD workflow documentation'
  key_links:
    - from: 'src/core/projection/index.test.ts'
      to: 'src/core/projection/index.ts'
      via: 'Import statements'
      pattern: "import { calculateProjection } from './index'"
    - from: 'vitest.config.ts'
      to: 'src/core/'
      via: 'Test environment configuration'
      pattern: 'environment: "node" (not jsdom)'
---

<objective>
Write comprehensive unit tests covering edge cases, error conditions, and boundary conditions for all engine functions, demonstrating TDD workflow with git history showing red-green-refactor cycle.

Purpose: Ensures financial calculation logic is thoroughly validated against edge cases (invalid inputs, boundary conditions, floating-point precision issues). Test suite serves as living documentation and prevents regressions. TDD workflow (tests first, then implementation) is verified through git commit history.

Output: Complete test suite with 90%+ coverage of edge cases, documentation of TDD workflow, and git history showing atomic commits following red-green-refactor cycle.
</objective>

<execution_context>
@/Users/zach/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zach/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/14-core-financial-engine/14-RESEARCH.md

Research reference: TDD Red-Green-Refactor Cycle (lines 118-152), Common Pitfalls - Testing Only Happy Paths (lines 211-224), Pitfall 4 - Skipping TDD Workflow (lines 241-254).
</context>

<tasks>

<task type="auto">
  <name>Verify existing test coverage and identify gaps</name>
  <files>
    src/core/projection/index.test.ts
    src/core/types/index.test.ts
  </files>
  <action>
    Review the test files created in plans 14-01 and 14-02 to ensure comprehensive edge case coverage.

    Run the existing test suite:
    ```bash
    npm test -- src/core/
    ```

    Check test coverage:
    ```bash
    npm run test:coverage -- src/core/
    ```

    Verify that tests cover:
    1. ✅ Happy paths (typical user profiles)
    2. ✅ Edge cases (zero values, age 100, age 0)
    3. ✅ Boundary conditions (negative balance prevention)
    4. ✅ Floating-point precision (using toBeCloseTo)
    5. ✅ Invalid input types (TypeScript compile-time checks)
    6. ✅ Data-driven tests (test.each for multiple scenarios)
    7. ✅ Determinism (same input produces same output)

    The tests from plans 14-01 and 14-02 should already cover all these scenarios. This task verifies completeness.

  </action>
  <verify>
    ```bash
    npm test -- src/core/
    npm run test:coverage -- src/core/
    ```
    All tests pass, coverage shows 100% for src/core/ files.
  </verify>
  <done>
    Existing test coverage verified as comprehensive, covering all edge cases and boundary conditions.
  </done>
</task>

<task type="auto">
  <name>Add floating-point precision edge case tests</name>
  <files>
    src/core/projection/index.test.ts
  </files>
  <action>
    Add specific tests for floating-point precision issues, which are critical in financial calculations.

    Add these tests to src/core/projection/index.test.ts:

    ```typescript
    describe('Floating-Point Precision', () => {
      it('should handle 0.1 + 0.2 precision correctly', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 0.1,
          annualGrowthRate: 0,
          annualSpending: 0,
        };

        const result = calculateProjection(profile);

        // JavaScript: 0.1 + 0.2 !== 0.3 (it's 0.30000000000000004)
        // But our calculations should handle this correctly
        expect(result[0].growth).toBe(0);
        expect(result[0].endingBalance).toBeCloseTo(0.1, 10);
      });

      it('should use toBeCloseTo for financial calculations', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7.123,
          annualSpending: 40000.987,
        };

        const result = calculateProjection(profile);

        // Floating-point growth calculation
        const expectedGrowth = 100000 * (7.123 / 100);
        expect(result[0].growth).toBeCloseTo(expectedGrowth, 2);

        // Ending balance with decimals
        expect(result[0].endingBalance).toBeCloseTo(
          100000 + expectedGrowth - 40000.987,
          2
        );
      });

      it('should accumulate precision correctly over multiple years', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100.33,
          annualGrowthRate: 5.5,
          annualSpending: 0,
        };

        const result = calculateProjection(profile);

        // Verify precision doesn't degrade over years
        let balance = 100.33;
        for (let i = 0; i < Math.min(5, result.length); i++) {
          const growth = balance * (5.5 / 100);
          balance = balance + growth;

          expect(result[i].startingBalance).toBeCloseTo(balance - growth, 2);
          expect(result[i].growth).toBeCloseTo(growth, 2);
          expect(result[i].endingBalance).toBeCloseTo(balance, 2);
        }
      });
    });
    ```

    These tests specifically validate floating-point arithmetic handling using toBeCloseTo().

  </action>
  <verify>
    ```bash
    npm test -- src/core/projection/index.test.ts
    ```
    All new floating-point precision tests pass.
  </verify>
  <done>
    Floating-point precision tests added, validating toBeCloseTo() usage and accumulated calculations over multiple years.
  </done>
</task>

<task type="auto">
  <name>Add boundary condition and stress tests</name>
  <files>
    src/core/projection/index.test.ts
  </files>
  <action>
    Add tests for extreme boundary conditions and stress scenarios.

    Add these tests to src/core/projection/index.test.ts:

    ```typescript
    describe('Boundary Conditions', () => {
      it('should handle very large savings amounts', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 10000000000, // 10 billion
          annualGrowthRate: 7,
          annualSpending: 400000,
        };

        const result = calculateProjection(profile);

        expect(result).toHaveLength(70);
        expect(result[0].growth).toBe(700000000); // 10B * 0.07
        expect(result[0].endingBalance).toBeGreaterThan(0);
      });

      it('should handle very small growth rates', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 0.01, // Near-zero growth
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        expect(result[0].growth).toBeCloseTo(10, 0); // 100000 * 0.0001
      });

      it('should handle very high growth rates', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 100, // 100% growth (unrealistic but valid input)
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        expect(result[0].growth).toBe(100000); // 100000 * 1.0
        expect(result[0].endingBalance).toBe(160000); // 100000 + 100000 - 40000
      });

      it('should handle spending exceeding savings with growth', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 5,
          annualSpending: 200000, // Spend more than starting balance
        };

        const result = calculateProjection(profile);

        // First year: 100000 + 5000 - 200000 = -95000 → 0 (floored)
        expect(result[0].endingBalance).toBe(0);

        // All subsequent years should also be zero
        for (let i = 1; i < Math.min(10, result.length); i++) {
          expect(result[i].endingBalance).toBe(0);
        }
      });

      it('should transition from positive to zero balance smoothly', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 5,
          annualSpending: 107000, // Slightly more than growth + starting
        };

        const result = calculateProjection(profile);

        // Year 0: 100000 + 5000 - 107000 = -2000 → 0
        expect(result[0].endingBalance).toBe(0);

        // Verify smooth transition (no negative values before floor)
        result.forEach((year) => {
          expect(year.endingBalance).toBeGreaterThanOrEqual(0);
        });
      });
    });

    describe('Determinism and Pure Function Properties', () => {
      it('should produce identical results on multiple calls', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const calls = Array.from({ length: 10 }, () => calculateProjection(profile));

        // All calls should produce identical results
        calls.forEach((result) => {
          expect(result).toEqual(calls[0]);
        });
      });

      it('should not mutate input profile', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const originalProfile = { ...profile };
        calculateProjection(profile);

        expect(profile).toEqual(originalProfile);
      });

      it('should not have side effects', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result1 = calculateProjection(profile);
        const result2 = calculateProjection(profile);

        // Results should be independent (not shared references)
        expect(result1).not.toBe(result2); // Different array references
        expect(result1).toEqual(result2); // Same values
      });
    });
    ```

    These tests validate extreme values, smooth transitions, and pure function properties.

  </action>
  <verify>
    ```bash
    npm test -- src/core/projection/index.test.ts
    ```
    All boundary condition and stress tests pass.
  </verify>
  <done>
    Boundary condition tests added for extreme values, balance transitions, and pure function properties (no mutations, no side effects).
  </done>
</task>

<task type="auto">
  <name>Verify test environment and configuration</name>
  <files>
    vitest.config.ts
    package.json
  </files>
  <action>
    Ensure tests run in the correct environment (node, not jsdom) and verify test scripts are configured properly.

    Check vitest.config.ts to ensure core tests run in node environment:
    ```bash
    cat vitest.config.ts
    ```

    The test environment for core files should be 'node' (not 'jsdom') to ensure zero React dependency verification.

    Verify package.json has test scripts:
    ```bash
    grep -A5 '"scripts"' package.json
    ```

    Should include:
    - "test": "vitest"
    - "test:coverage": "vitest --coverage"

    Run tests with coverage to verify configuration:
    ```bash
    npm run test:coverage -- src/core/
    ```

    This should generate a coverage report showing 100% coverage for src/core/ files.

  </action>
  <verify>
    ```bash
    npm run test:coverage -- src/core/
    ```
    Coverage report shows 100% for src/core/projection/index.ts and src/core/types/index.ts.
  </verify>
  <done>
    Test environment verified (node environment), coverage reporting working, 100% coverage achieved for core files.
  </done>
</task>

<task type="auto">
  <name>Document TDD workflow and verify git history</name>
  <files>
    14-03-SUMMARY.md
  </files>
  <action>
    Create comprehensive documentation of the TDD workflow used and verify git history demonstrates atomic commits following red-green-refactor cycle.

    First, examine git log to verify commit pattern:
    ```bash
    git log --oneline --all -20
    ```

    Look for commit messages like:
    - "test: add failing test for calculateProjection" (RED)
    - "feat: implement calculateProjection function" (GREEN)
    - "refactor: simplify calculation logic" (REFACTOR - if applicable)

    Then create 14-03-SUMMARY.md with:
    1. Test coverage summary (number of tests, edge cases covered)
    2. TDD workflow documentation (red → green → refactor cycle)
    3. Git commit history showing atomic TDD commits
    4. Coverage report results
    5. Verification of zero React imports

    Example summary structure:
    ```markdown
    # Phase 14 Plan 03 Summary: Comprehensive Test Coverage

    ## Test Coverage Summary

    ### src/core/types/index.test.ts
    - Total tests: X
    - Coverage: 100%
    - Edge cases: readonly enforcement, zero values, type validation

    ### src/core/projection/index.test.ts
    - Total tests: Y
    - Coverage: 100%
    - Edge cases: boundary conditions, floating-point precision, negative balance prevention

    ## TDD Workflow Demonstrated

    ### Red Phase (Failing Tests)
    - Commit: abc1234 - "test: add failing tests for UserProfile and SimulationResult types"
    - Commit: def5678 - "test: add failing tests for calculateProjection function"

    ### Green Phase (Implementation)
    - Commit: ghi9012 - "feat: implement UserProfile and SimulationResult types"
    - Commit: jkl3456 - "feat: implement calculateProjection function"

    ### Refactor Phase (If applicable)
    - No refactoring needed - implementation was clean from start

    ## Edge Cases Covered

    1. Zero values (age, savings, growth, spending)
    2. Boundary conditions (age 100, age 0)
    3. Negative balance prevention
    4. Floating-point precision
    5. Determinism and pure function properties
    6. Extreme values (large amounts, high growth rates)
    7. Invalid input types (TypeScript compile-time)

    ## Verification

    - ✅ All tests pass (npm test -- src/core/)
    - ✅ 100% code coverage
    - ✅ Zero React imports (grep -r "from ['\"]react" src/core/)
    - ✅ Tests run in node environment (not jsdom)
    - ✅ Git history shows TDD atomic commits
    ```

  </action>
  <verify>
    ```bash
    git log --oneline -10
    cat .planning/phases/14-core-financial-engine/14-03-SUMMARY.md
    ```
    Git history shows TDD workflow, summary documentation created.
  </verify>
  <done>
    TDD workflow documented in summary, git history verified to show red-green-refactor cycle, comprehensive edge case coverage confirmed.
  </done>
</task>

</tasks>

<verification>
Overall Phase 14 Verification (after all plans complete):

1. Run `npm test -- src/core/` - verify all tests pass (types + projection)
2. Run `npm run test:coverage -- src/core/` - verify 100% coverage
3. Run `grep -r "from ['\"]react" src/core/` - verify zero React imports
4. Run `npx tsc --noEmit` - verify TypeScript compilation succeeds
5. Check git history - verify atomic commits showing TDD workflow
6. Manual calculation spot-check - verify first year calculations match expected values
7. Test edge cases manually - verify age 100 returns empty array, zero balance prevention works
</verification>

<success_criteria>

1. All engine functions have comprehensive unit tests (25+ test cases total)
2. Tests cover edge cases: zero values, boundary conditions, invalid inputs, floating-point precision
3. Test suite passes with 100% code coverage for src/core/ files
4. TDD workflow demonstrated in git history (failing tests before implementation)
5. Zero React imports verified in src/core/ directory
6. Tests run in node environment (not jsdom) for true isolation
7. Documentation created explaining TDD red-green-refactor cycle
8. Git commits show atomic changes (test → implement → refactor)
9. TypeScript compilation succeeds with no errors
10. Manual verification confirms calculations are accurate
</success_criteria>

<output>
After completion, create `.planning/phases/14-core-financial-engine/14-03-SUMMARY.md` with:
- Complete test coverage report (number of tests, coverage percentage)
- TDD workflow documentation with git commit references
- Edge cases covered and test scenarios
- Verification of zero React imports and test isolation
- Coverage report results and any gaps identified
- Git history showing red-green-refactor cycle
- Summary of Phase 14 completion (all three plans complete)
</output>

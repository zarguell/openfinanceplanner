---
phase: 14-core-financial-engine
plan: 02
type: execute
wave: 1
depends_on:
  - 14-01
files_modified:
  - src/core/projection/index.ts
  - src/core/projection/index.test.ts
  - src/core/index.ts
autonomous: true

must_haves:
  truths:
    - 'calculateProjection function accepts UserProfile and returns SimulationResult[]'
    - 'Function implements year-by-year compound interest calculation'
    - 'Engine code has zero React imports (pure TypeScript)'
    - 'Calculations handle edge cases (zero values, age 100, negative balance prevention)'
    - 'Function is deterministic (same input always produces same output)'
    - 'Export available via @/core/projection path alias'
  artifacts:
    - path: 'src/core/projection/index.ts'
      provides: 'Pure function for year-by-year financial projection'
      exports: ['calculateProjection']
      contains: ['function calculateProjection', 'Math.max(0, balance)']
    - path: 'src/core/projection/index.test.ts'
      provides: 'Comprehensive tests for projection calculation logic'
      contains: ['describe', 'it', 'calculateProjection', 'toBeCloseTo', 'test.each']
    - path: 'src/core/index.ts'
      provides: 'Namespace exports for clean engine layer'
      exports: ['export * from', '@/core/projection', '@/core/types']
  key_links:
    - from: 'src/core/projection/index.ts'
      to: 'src/core/types/index.ts'
      via: 'TypeScript type imports'
      pattern: 'import type { UserProfile, SimulationResult } from "@/core/types"'
    - from: 'src/core/index.ts'
      to: 'src/core/projection/index.ts'
      via: 'Re-export'
      pattern: 'export * from "./projection"'
---

<objective>
Implement calculateProjection pure function with year-by-year compound interest logic in src/core/projection, following TDD methodology.

Purpose: Creates the core financial calculation engine that projects year-by-year savings growth, investment returns, and spending. Pure function design ensures testability and prevents side effects. Completely decoupled from React for isolated unit testing.

Output: Working calculateProjection function with comprehensive test coverage, handling edge cases and preventing negative balances, exported via @/core/projection.
</objective>

<execution_context>
@/Users/zach/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zach/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/14-core-financial-engine/14-RESEARCH.md

Research reference: Pure Function Projection Engine pattern (lines 65-114), TDD Red-Green-Refactor Cycle (lines 118-152), Code Examples section (lines 260-307).
</context>

<tasks>

<task type="auto">
  <name>Create projection directory and write failing tests (TDD RED phase)</name>
  <files>
    src/core/projection/index.test.ts
  </files>
  <action>
    Create the test file BEFORE implementing the function. This is strict TDD: tests must fail first, then implementation makes them pass.

    Create src/core/projection/index.test.ts:

    ```typescript
    import { describe, it, expect, test } from 'vitest';
    import { calculateProjection } from './index';
    import type { UserProfile } from '@/core/types';

    describe('calculateProjection', () => {
      it('should calculate year-by-year projection for typical profile', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        // Should project until age 100 (70 years)
        expect(result).toHaveLength(70);

        // First year calculation
        expect(result[0].year).toBe(0);
        expect(result[0].age).toBe(30);
        expect(result[0].startingBalance).toBe(100000);
        expect(result[0].growth).toBeCloseTo(7000, 0); // 100000 * 0.07
        expect(result[0].spending).toBe(40000);
        expect(result[0].endingBalance).toBeCloseTo(67000, 0); // 100000 + 7000 - 40000
      });

      it('should project until age 100', () => {
        const profile: UserProfile = {
          age: 50,
          currentSavings: 500000,
          annualGrowthRate: 5,
          annualSpending: 60000,
        };

        const result = calculateProjection(profile);

        expect(result).toHaveLength(50); // Until age 100
        expect(result[0].age).toBe(50);
        expect(result[result.length - 1].age).toBe(99); // Last year ends at age 99 (projection for age 100)
      });

      it('should handle zero growth rate', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 0,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        expect(result[0].growth).toBe(0);
        expect(result[0].endingBalance).toBe(60000); // 100000 - 40000
      });

      it('should handle zero spending', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 0,
        };

        const result = calculateProjection(profile);

        expect(result[0].spending).toBe(0);
        expect(result[0].endingBalance).toBeCloseTo(107000, 0); // 100000 + 7000
      });

      it('should prevent negative balances (floor at zero)', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 10000,
          annualGrowthRate: 5,
          annualSpending: 50000, // High spending depletes savings quickly
        };

        const result = calculateProjection(profile);

        // Balance should never go negative
        result.forEach((year) => {
          expect(year.endingBalance).toBeGreaterThanOrEqual(0);
        });

        // Once balance hits zero, it stays zero
        const zeroYear = result.findIndex((y) => y.endingBalance === 0);
        if (zeroYear !== -1) {
          for (let i = zeroYear; i < result.length; i++) {
            expect(result[i].endingBalance).toBe(0);
          }
        }
      });

      it('should handle age 100 (no projection needed)', () => {
        const profile: UserProfile = {
          age: 100,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        expect(result).toHaveLength(0); // No years to project
      });

      it('should handle age 0 (100-year projection)', () => {
        const profile: UserProfile = {
          age: 0,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        expect(result).toHaveLength(100); // Project until age 100
        expect(result[0].age).toBe(0);
        expect(result[result.length - 1].age).toBe(99);
      });

      it('should handle zero savings', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 0,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        expect(result[0].startingBalance).toBe(0);
        expect(result[0].growth).toBe(0);
        expect(result[0].endingBalance).toBe(0); // Floor at zero
      });

      it('should be deterministic (same input produces same output)', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result1 = calculateProjection(profile);
        const result2 = calculateProjection(profile);

        expect(result1).toEqual(result2);
      });

      it('should handle decimal growth rates precisely', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7.5,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        expect(result[0].growth).toBeCloseTo(7500, 0); // 100000 * 0.075
        expect(result[0].endingBalance).toBeCloseTo(67500, 0); // 100000 + 7500 - 40000
      });

      test.each([
        [30, 100000, 7, 40000, 70, 'typical retirement'],
        [50, 500000, 5, 60000, 50, 'late starter'],
        [25, 50000, 8, 30000, 75, 'early starter'],
        [40, 250000, 6, 50000, 60, 'mid-career'],
      ])(
        'calculates projection for %s',
        (age, savings, rate, spending, expectedYears, scenario) => {
          const profile: UserProfile = {
            age,
            currentSavings: savings,
            annualGrowthRate: rate,
            annualSpending: spending,
          };

          const result = calculateProjection(profile);

          expect(result).toHaveLength(expectedYears);
          expect(result[0].age).toBe(age);
        }
      );

      it('should ensure year progression is sequential', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        for (let i = 0; i < result.length; i++) {
          expect(result[i].year).toBe(i);
        }
      });

      it('should ensure age progression is sequential', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7,
          annualSpending: 40000,
        };

        const result = calculateProjection(profile);

        for (let i = 0; i < result.length; i++) {
          expect(result[i].age).toBe(30 + i);
        }
      });
    });
    ```

    This test file WILL FAIL initially because calculateProjection doesn't exist yet. This is the correct TDD RED phase.

  </action>
  <verify>
    ```bash
    npm test -- src/core/projection/index.test.ts
    ```
    Tests should FAIL (red phase) because calculateProjection doesn't exist yet.
  </verify>
  <done>
    Comprehensive test file created with 14+ test cases covering happy paths, edge cases, and boundary conditions. Tests failing as expected.
  </done>
</task>

<task type="auto">
  <name>Implement calculateProjection pure function (TDD GREEN phase)</name>
  <files>
    src/core/projection/index.ts
  </files>
  <action>
    Implement the calculateProjection function to make all tests pass. Following TDD, implement ONLY what's needed to pass tests - no more, no less.

    Create src/core/projection/index.ts:

    ```typescript
    import type { UserProfile, SimulationResult } from '@/core/types';

    /**
     * Calculate year-by-year financial projection
     *
     * Pure function that takes a user profile and returns an array of
     * simulation results, one for each year from current age until age 100.
     *
     * Algorithm:
     * 1. Start with current savings
     * 2. For each year:
     *    - Calculate growth: startingBalance * (annualGrowthRate / 100)
     *    - Subtract spending
     *    - Update balance (floor at 0 to prevent negative values)
     * 3. Return array of yearly results
     *
     * @param profile - User profile with age, savings, growth rate, and spending
     * @returns Array of simulation results, one per year until age 100
     */
    export function calculateProjection(
      profile: UserProfile
    ): SimulationResult[] {
      const results: SimulationResult[] = [];
      let balance = profile.currentSavings;

      // Project from current age until age 100
      const yearsToProject = 100 - profile.age;

      for (let year = 0; year < yearsToProject; year++) {
        const age = profile.age + year;
        const startingBalance = balance;

        // Calculate investment growth
        const growth = startingBalance * (profile.annualGrowthRate / 100);

        // Update balance: starting + growth - spending
        balance = startingBalance + growth - profile.annualSpending;

        // Prevent negative balances (floor at zero)
        const endingBalance = Math.max(0, balance);

        results.push({
          year,
          age,
          startingBalance,
          growth,
          spending: profile.annualSpending,
          endingBalance,
        });

        // If we hit zero, all subsequent years will also be zero
        // No need to break early - tests verify this behavior
        balance = endingBalance;
      }

      return results;
    }
    ```

    Key implementation details:
    - Pure function: no side effects, deterministic output
    - Uses types from @/core/types (path alias)
    - Math.max(0, balance) prevents negative balances
    - Sequential year and age progression
    - Loop runs from current age until 100
    - No React imports - pure TypeScript

  </action>
  <verify>
    ```bash
    npm test -- src/core/projection/index.test.ts
    ```
    All tests should now PASS (green phase).
  </verify>
  <done>
    calculateProjection function implemented with year-by-year compound interest logic, negative balance prevention, and all tests passing.
  </done>
</task>

<task type="auto">
  <name>Create namespace exports in src/core/index.ts</name>
  <files>
    src/core/index.ts
  </files>
  <action>
    Create a clean namespace export for the entire core layer. This allows consumers to import from @/core instead of specific subdirectories.

    Create src/core/index.ts:

    ```typescript
    // Type exports
    export type { UserProfile, SimulationResult } from './types';

    // Function exports
    export { calculateProjection } from './projection';
    ```

    This enables cleaner imports:
    - Instead of: `import { calculateProjection } from '@/core/projection'`
    - Use: `import { calculateProjection } from '@/core'`

  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    ```
    TypeScript compilation should succeed with no errors.
  </verify>
  <done>
    Namespace exports created in src/core/index.ts, enabling @/core imports for types and functions.
  </done>
</task>

<task type="auto">
  <name>Verify zero React imports and run full test suite</name>
  <files>
    src/core/projection/index.ts
    src/core/projection/index.test.ts
  </files>
  <action>
    Verify that the engine layer has zero React dependencies and all tests pass.

    First, grep for React imports in the core directory:
    ```bash
    grep -r "from ['\"]react" src/core/
    ```

    This should return NO RESULTS, confirming complete decoupling from React.

    Then run all core tests:
    ```bash
    npm test -- src/core/
    ```

    Finally, verify TypeScript compilation:
    ```bash
    npx tsc --noEmit
    ```

  </action>
  <verify>
    ```bash
    grep -r "from ['\"]react" src/core/
    npm test -- src/core/
    npx tsc --noEmit
    ```
    No React imports found, all tests pass, TypeScript compilation succeeds.
  </verify>
  <done>
    Verified zero React imports in src/core/, all projection tests pass, TypeScript compilation successful.
  </done>
</task>

</tasks>

<verification>
Plan-Specific Verification:

1. Run `npm test -- src/core/projection/index.test.ts` - verify all 14+ tests pass
2. Run `grep -r "from ['\"]react" src/core/` - verify zero React imports
3. Run `npx tsc --noEmit` - verify TypeScript compilation with no errors
4. Check that calculateProjection is exported from @/core and @/core/projection
5. Manually verify calculations for first year match expected values (growth, ending balance)
6. Test edge cases: age 100 (empty array), zero spending, zero growth, negative balance prevention
</verification>

<success_criteria>

1. calculateProjection function implemented in src/core/projection/index.ts
2. Function accepts UserProfile parameter and returns SimulationResult[]
3. Year-by-year calculations use compound interest: startingBalance * (growthRate / 100)
4. Negative balances prevented with Math.max(0, balance)
5. All 14+ tests pass (npm test -- src/core/projection/index.test.ts)
6. Zero React imports in src/core/ directory
7. TypeScript compilation succeeds (npx tsc --noEmit)
8. Namespace exports available via @/core/index.ts
9. Function is deterministic (same input produces same output)
10. Edge cases handled: age 100, zero values, negative balance prevention
</success_criteria>

<output>
After completion, create `.planning/phases/14-core-financial-engine/14-02-SUMMARY.md` with:
- Confirmation of calculateProjection implementation
- Test results summary (all tests passing)
- Verification of zero React imports
- Git commit message following TDD workflow
- Manual calculation spot-check results
</output>

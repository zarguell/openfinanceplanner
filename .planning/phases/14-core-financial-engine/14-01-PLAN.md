---
phase: 14-core-financial-engine
plan: 01
type: execute
wave: 1
depends_on:
  - 13-architecture-testing-foundation
files_modified:
  - src/core/types/index.ts
  - src/core/types/index.test.ts
autonomous: true

must_haves:
  truths:
    - 'UserProfile type defines age, currentSavings, annualGrowthRate, annualSpending as readonly'
    - 'SimulationResult type defines year, age, startingBalance, growth, spending, endingBalance as readonly'
    - 'Types export correctly via @/core/types path alias'
    - 'TypeScript compiler validates all type constraints at compile time'
    - 'Type definitions exist in isolated src/core/types/ directory with zero React imports'
  artifacts:
    - path: 'src/core/types/index.ts'
      provides: 'Core financial domain types for projection engine'
      exports: ['UserProfile', 'SimulationResult']
      contains: ['Readonly', 'age', 'currentSavings', 'annualGrowthRate', 'annualSpending', 'year', 'startingBalance', 'growth', 'spending', 'endingBalance']
    - path: 'src/core/types/index.test.ts'
      provides: 'Type validation tests ensuring compile-time safety'
      contains: ['describe', 'it', 'expect', 'UserProfile', 'SimulationResult']
  key_links:
    - from: 'src/core/types/index.ts'
      to: 'future engine functions'
      via: 'TypeScript type system'
      pattern: 'UserProfile, SimulationResult'
    - from: 'tsconfig.json'
      to: 'src/core/types/index.ts'
      via: 'Path alias resolution'
      pattern: '@/core/types'
---

<objective>
Define TypeScript types (UserProfile, SimulationResult) in src/core/types as the foundation for the financial projection engine.

Purpose: Establishes the data contract for all financial calculations. Using Readonly interfaces ensures immutability and prevents accidental mutations in pure functions. Types are completely decoupled from React, enabling unit testing in isolation.

Output: Type definitions with TypeScript strict mode enforcement, testable without React dependencies, exported via @/core/types alias.
</objective>

<execution_context>
@/Users/zach/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zach/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/phases/14-core-financial-engine/14-RESEARCH.md

Research reference: Pure Function Projection Engine pattern (lines 65-114), Code Examples section (lines 256-307). Types use Readonly interface for immutability.
</context>

<tasks>

<task type="auto">
  <name>Create test file first (TDD RED phase)</name>
  <files>
    src/core/types/index.test.ts
  </files>
  <action>
    Create the test file BEFORE implementing the types. This follows TDD methodology: write failing tests first, then implement to make them pass.

    Create src/core/types/index.test.ts:

    ```typescript
    import { describe, it, expect } from 'vitest';
    import type { UserProfile, SimulationResult } from './index';

    describe('Core Types - UserProfile', () => {
      it('should accept valid user profile data', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7.5,
          annualSpending: 40000,
        };

        expect(profile.age).toBe(30);
        expect(profile.currentSavings).toBe(100000);
        expect(profile.annualGrowthRate).toBe(7.5);
        expect(profile.annualSpending).toBe(40000);
      });

      it('should enforce readonly properties', () => {
        const profile: UserProfile = {
          age: 30,
          currentSavings: 100000,
          annualGrowthRate: 7.5,
          annualSpending: 40000,
        };

        // TypeScript should prevent mutation at compile time
        // @ts-expect-error - Cannot assign to 'age' because it is a read-only property
        profile.age = 31;
      });

      it('should accept zero and edge case values', () => {
        const zeroProfile: UserProfile = {
          age: 0,
          currentSavings: 0,
          annualGrowthRate: 0,
          annualSpending: 0,
        };

        expect(zeroProfile.age).toBe(0);
        expect(zeroProfile.currentSavings).toBe(0);
      });

      it('should reject invalid types at compile time', () => {
        // @ts-expect-error - Type 'string' is not assignable to type 'number'
        const invalidProfile: UserProfile = {
          age: '30',
          currentSavings: 100000,
          annualGrowthRate: 7.5,
          annualSpending: 40000,
        };
      });
    });

    describe('Core Types - SimulationResult', () => {
      it('should accept valid simulation result data', () => {
        const result: SimulationResult = {
          year: 0,
          age: 30,
          startingBalance: 100000,
          growth: 7000,
          spending: 40000,
          endingBalance: 67000,
        };

        expect(result.year).toBe(0);
        expect(result.age).toBe(30);
        expect(result.startingBalance).toBe(100000);
        expect(result.growth).toBe(7000);
        expect(result.spending).toBe(40000);
        expect(result.endingBalance).toBe(67000);
      });

      it('should enforce readonly properties', () => {
        const result: SimulationResult = {
          year: 0,
          age: 30,
          startingBalance: 100000,
          growth: 7000,
          spending: 40000,
          endingBalance: 67000,
        };

        // TypeScript should prevent mutation
        // @ts-expect-error - Cannot assign to 'year' because it is a read-only property
        result.year = 1;
      });

      it('should handle decimal precision values', () => {
        const preciseResult: SimulationResult = {
          year: 0,
          age: 30,
          startingBalance: 100000.50,
          growth: 7500.04,
          spending: 40000.99,
          endingBalance: 67000.55,
        };

        expect(preciseResult.startingBalance).toBeCloseTo(100000.50, 2);
        expect(preciseResult.growth).toBeCloseTo(7500.04, 2);
      });
    });

    describe('Core Types - Type Safety', () => {
      it('should ensure types are exported correctly', () => {
        // This test verifies that types can be imported
        // If types don't exist, this will fail at compile time
        const typeCheck = true;

        expect(typeof typeCheck).toBe('boolean');
      });

      it('should have zero React imports', () => {
        // Verify no React dependencies in type definitions
        // This is a compile-time check - the file should not import from 'react'
        const noReactImports = true;

        expect(noReactImports).toBe(true);
      });
    });
    ```

    This test file WILL FAIL initially because the types don't exist yet. This is the correct TDD RED phase.

  </action>
  <verify>
    ```bash
    npm test -- src/core/types/index.test.ts
    ```
    Tests should FAIL (red phase) because types don't exist yet.
  </verify>
  <done>
    Test file created with failing tests demonstrating type requirements, readonly enforcement, and edge case handling.
  </done>
</task>

<task type="auto">
  <name>Implement type definitions (TDD GREEN phase)</name>
  <files>
    src/core/types/index.ts
  </files>
  <action>
    Create the type definitions to make the tests pass. Following TDD methodology, implement ONLY what's needed to make tests pass.

    Create src/core/types/index.ts:

    ```typescript
    /**
     * User profile data for financial projection
     *
     * All properties are readonly to ensure immutability in pure functions.
     * Annual growth rate is expressed as a percentage (e.g., 7.5 for 7.5%).
     */
    export type UserProfile = Readonly<{
      /** Current age in years (0-100) */
      age: number;
      /** Total current savings/investments in dollars */
      currentSavings: number;
      /** Expected annual growth rate as percentage (e.g., 7.5 for 7.5%) */
      annualGrowthRate: number;
      /** Annual spending/withdrawal amount in dollars */
      annualSpending: number;
    }>;

    /**
     * Single year simulation result
     *
     * Represents the financial state for one year of the projection.
     * All properties are readonly to ensure immutability.
     */
    export type SimulationResult = Readonly<{
      /** Year index (0 = first year of projection) */
      year: number;
      /** Age at the end of this year */
      age: number;
      /** Starting balance for this year */
      startingBalance: number;
      /** Investment growth earned this year */
      growth: number;
      /** Amount spent/withdrawn this year */
      spending: number;
      /** Ending balance after growth and spending */
      endingBalance: number;
    }>;
    ```

    Key implementation details:
    - Use `Readonly<>` wrapper to enforce immutability
    - Use `export type` (not interface) for consistency with pure function pattern
    - Include JSDoc comments for IDE tooltips and documentation
    - DO NOT import anything from React - this is pure TypeScript

  </action>
  <verify>
    ```bash
    npm test -- src/core/types/index.test.ts
    ```
    All tests should now PASS (green phase).
  </verify>
  <done>
    Type definitions implemented with Readonly properties, JSDoc documentation, zero React imports, and all tests passing.
  </done>
</task>

<task type="auto">
  <name>Verify TypeScript compilation and path alias resolution</name>
  <files>
    src/core/types/index.ts
    tsconfig.json
  </files>
  <action>
    Verify that the types are properly accessible via the @/core/types path alias and that TypeScript compilation succeeds.

    First, run TypeScript compiler to check for type errors:
    ```bash
    npx tsc --noEmit
    ```

    This should complete without errors, confirming:
    - Type definitions are syntactically correct
    - Path aliases are resolving correctly
    - Strict mode is enforcing type safety

    Then verify the tests pass:
    ```bash
    npm test -- src/core/types/index.test.ts
    ```

    Finally, verify types can be imported using the path alias by checking the test file imports work correctly.

  </action>
  <verify>
    ```bash
    npx tsc --noEmit
    npm test -- src/core/types/index.test.ts
    ```
    TypeScript compiler completes with exit code 0, all tests pass.
  </verify>
  <done>
    TypeScript compilation succeeds with no errors, path alias @/core/types resolves correctly, all type tests pass.
  </done>
</task>

</tasks>

<verification>
Plan-Specific Verification:

1. Run `npx tsc --noEmit` - verify TypeScript compilation with no errors
2. Run `npm test -- src/core/types/index.test.ts` - verify all type validation tests pass
3. Check that src/core/types/index.ts has zero imports from 'react' or 'react-dom'
4. Verify types are exported and can be imported via `@/core/types`
5. Confirm Readonly properties prevent mutation at compile time
</verification>

<success_criteria>

1. UserProfile type defined with age, currentSavings, annualGrowthRate, annualSpending as Readonly properties
2. SimulationResult type defined with year, age, startingBalance, growth, spending, endingBalance as Readonly properties
3. All types export correctly from src/core/types/index.ts
4. Test file src/core/types/index.test.ts validates type constraints and readonly enforcement
5. TypeScript compiler (npx tsc --noEmit) completes with zero errors
6. Path alias @/core/types resolves correctly in imports
7. Zero React imports in src/core/types/ directory
8. All tests pass (npm test -- src/core/types/index.test.ts)
</success_criteria>

<output>
After completion, create `.planning/phases/14-core-financial-engine/14-01-SUMMARY.md` with:
- Confirmation of types created (UserProfile, SimulationResult)
- Verification that all tests pass
- TypeScript compilation success confirmation
- Git commit message following TDD workflow (test first, then implementation)
</output>

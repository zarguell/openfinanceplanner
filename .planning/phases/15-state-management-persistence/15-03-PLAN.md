---
phase: 15-state-management-persistence
plan: 03
type: execute
wave: 2
depends_on: [15-01, 15-02]
files_modified:
  - src/store/utils/export.ts
  - src/store/utils/import.ts
  - src/store/utils/index.ts
  - src/store/index.test.ts
autonomous: true

must_haves:
  truths:
    - "Export utility downloads JSON file with current state"
    - "Export file named with date (finance-planner-YYYY-MM-DD.json)"
    - "Import utility reads JSON file and validates structure"
    - "Import validates required fields (profile, projection) exist"
    - "Import throws error for malformed JSON or missing fields"
    - "Tests verify export creates downloadable blob"
    - "Tests verify import validates and parses correctly"
  artifacts:
    - path: "src/store/utils/export.ts"
      provides: "JSON export functionality"
      exports: ["exportState"]
      min_lines: 15
    - path: "src/store/utils/import.ts"
      provides: "JSON import with validation"
      exports: ["importState"]
      min_lines: 20
    - path: "src/store/index.test.ts"
      provides: "Store and utility tests"
      contains: "describe("
      min_lines: 50
  key_links:
    - from: "src/store/utils/export.ts"
      to: "src/store/types.ts"
      via: "import StoreState type"
      pattern: "from '../types'"
    - from: "src/store/utils/import.ts"
      to: "src/store/types.ts"
      via: "import StoreState type for validation"
      pattern: "from '../types'"
    - from: "src/store/index.test.ts"
      to: "src/store"
      via: "test all store functionality"
      pattern: "from '@/store'"
---

<objective>
Implement JSON export/import utilities for state backup and restore, with comprehensive tests for store persistence and utilities.

Purpose: Phase 15 requires JSON export (STATE-04) and import (STATE-05) functionality. This plan implements client-side file download/export, file upload/import with validation, and tests for the complete store system.

Output: Export and import utilities, comprehensive test coverage for store and utilities
</objective>

<execution_context>
@/Users/zach/.claude/get-shit-done/workflows/execute-plan.md
@/Users/zach/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/15-state-management-persistence/15-RESEARCH.md
@.planning/phases/15-state-management-persistence/15-01-SUMMARY.md
@.planning/phases/15-state-management-persistence/15-02-SUMMARY.md
@src/store/index.ts
@src/store/types.ts
@src/store/middleware/indexeddb.ts
</context>

<tasks>

<task type="auto">
  <name>Implement JSON export utility</name>
  <files>src/store/utils/export.ts</files>
  <action>
    Create src/store/utils/export.ts with exportState function:

    1. Import StoreState type from '../types'
    2. Create exportState function that accepts StoreState
    3. Stringify state with JSON.stringify(state, null, 2) for pretty formatting
    4. Create Blob with data and type 'application/json'
    5. Create object URL with URL.createObjectURL(blob)
    6. Create temporary anchor element:
      - Set href to object URL
      - Set download to `finance-planner-${new Date().toISOString().split('T')[0]}.json`
      - Append to document.body
      - Click to trigger download
      - Remove from document.body
    7. Revoke object URL with URL.revokeObjectURL(url) to prevent memory leak

    Follow Pattern 4 from RESEARCH.md exactly. Clean up DOM elements and revoke URL to prevent memory leaks (Pitfall 4).
  </action>
  <verify>test -f src/store/utils/export.ts && grep -q "exportState" src/store/utils/export.ts && grep -q "URL.createObjectURL" src/store/utils/export.ts && grep -q "URL.revokeObjectURL" src/store/utils/export.ts && npm run type-check</verify>
  <done>Export utility creates downloadable JSON file with date in filename, proper cleanup to prevent memory leaks</done>
</task>

<task type="auto">
  <name>Implement JSON import utility with validation</name>
  <files>src/store/utils/import.ts</files>
  <action>
    Create src/store/utils/import.ts with importState function:

    1. Import StoreState type from '../types'
    2. Create importState function that accepts File and returns Promise<StoreState>
    3. Return Promise wrapping FileReader:
      - reader.onload: Parse JSON, validate structure, resolve with data
      - reader.onerror: Reject with reader.error
      - Call reader.readAsText(file)
    4. Validation in onload handler:
      - Check typeof data === 'object' and data !== null
      - Check data has required structure (at minimum an object with expected keys)
      - Throw error if validation fails
    5. Import throws meaningful errors for invalid JSON or missing fields

    Follow Pattern 5 from RESEARCH.md. Include validation to prevent corrupted state (Pitfall 5).
    Do NOT use useStore.setState in this utility - that's the component's responsibility.
  </action>
  <verify>test -f src/store/utils/import.ts && grep -q "importState" src/store/utils/import.ts && grep -q "FileReader" src/store/utils/import.ts && npm run type-check</verify>
  <done>Import utility reads JSON file, validates structure, returns parsed state or throws error</done>
</task>

<task type="auto">
  <name>Create utils index file</name>
  <files>src/store/utils/index.ts</files>
  <action>
    Create src/store/utils/index.ts that re-exports exportState and importState:

    1. Export { exportState } from './export'
    2. Export { importState } from './import'

    This provides a clean API for importing utilities: import { exportState, importState } from '@/store/utils'
  </action>
  <verify>test -f src/store/utils/index.ts && grep -q "exportState" src/store/utils/index.ts && grep -q "importState" src/store/utils/index.ts && npm run type-check</verify>
  <done>Utils index exports both exportState and importState for clean imports</done>
</task>

<task type="auto">
  <name>Write tests for store and utilities</name>
  <files>src/store/index.test.ts</files>
  <action>
    Create src/store/index.test.ts with comprehensive tests:

    1. Import useStore, actions from './index'
    2. Import { exportState } from './utils/export'
    3. Import { importState } from './utils/import'
    4. Import type { UserProfile } from '@/core/types'
    5. Test store actions:
       - setProfile updates profile state
       - clearProfile sets profile to null
       - setProjection updates projection state
       - clearProjection sets projection to null
       - setHasHydrated updates _hasHydrated state
    6. Test export utility:
       - exportState creates blob with correct content type
       - exportState generates filename with current date
    7. Test import utility:
       - importState parses valid JSON correctly
       - importState throws on malformed JSON
       - importState validates object structure
    8. Mock DOM APIs for export tests (Blob, URL, createElement)
    9. Mock FileReader for import tests

    Use jsdom environment for DOM API mocking. Use vi.mock() for URL.createObjectURL and related APIs.
    Follow test patterns from Phase 14 (describe/it/expect structure).
  </action>
  <verify>test -f src/store/index.test.ts && npm run test:run -- src/store/index.test.ts</verify>
  <done>Test file exists with all store actions tested, export utility tested, import utility tested, all tests pass</done>
</task>

</tasks>

<verification>
Run npm run test:run to verify all tests pass. Run npm run test:coverage to verify coverage meets threshold. Run npm run type-check to verify TypeScript types.
</verification>

<success_criteria>
1. src/store/utils/ directory created with export.ts, import.ts, index.ts
2. exportState function creates downloadable JSON blob with date filename
3. importState function reads file, validates, returns parsed state
4. Both utilities handle errors appropriately (memory leak cleanup, validation errors)
5. Test file covers all store actions and utility functions
6. All tests pass (npm run test:run)
7. TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/15-state-management-persistence/15-03-SUMMARY.md`
</output>

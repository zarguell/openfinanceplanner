---
phase: 05-test-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - tests/unit/models/Plan.test.js
  - tests/unit/models/Account.test.js
  - tests/unit/models/Income.test.js
  - tests/unit/models/Expense.test.js
  - tests/unit/core/rules/BackdoorRothRule.test.js
  - tests/unit/core/rules/RuleRegistry.test.js
  - tests/unit/storage/StorageManager.test.js
  - tests/unit/calculations/tax.test.js
  - tests/unit/calculations/tax-state.test.js
  - tests/unit/calculations/projection.test.js
  - tests/unit/calculations/income.test.js
  - tests/unit/calculations/qcd.test.js
  - tests/unit/calculations/roth-conversions.test.js
  - tests/unit/calculations/rmd.test.js
  - tests/unit/calculations/social-security.test.js
  - tests/unit/calculations/tax-loss-harvesting.test.js
  - tests/unit/calculations/withdrawal-strategies.test.js
  - tests/unit/calculations/monte-carlo.test.js
  - tests/unit/ui/AppController.test.js
autonomous: true
must_haves:
  truths:
    - 'All unit tests use Vitest describe/it/expect format'
    - 'No import.meta.url execution guards remain in test files'
    - 'All unit tests pass with vitest run'
  artifacts:
    - path: 'tests/unit/models/Plan.test.js'
      provides: 'Unit test migrated to Vitest'
      contains: 'describe(), it(), expect() instead of custom runner'
    - path: 'tests/unit/calculations/tax.test.js'
      provides: 'Tax calculation tests migrated'
      contains: 'Vitest assertions for federal tax calculations'
  key_links:
    - from: 'tests/unit/**/*.test.js'
      to: 'vitest.config.js'
      via: 'Test discovery and execution'
---

<objective>
Migrate all unit tests from custom test runner format to Vitest describe/it/expect format.

Purpose: Replace manual throw Error assertions and import.meta.url execution guards with Vitest's standard test API for better error messages, test organization, and automatic test discovery.

Output: All 19 unit test files converted to Vitest format, vitest.config.js updated if needed, all tests passing with `npm test`.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-test-migration/05-RESEARCH.md

# Phase context:

# - Phase 1 installed Vitest 4.0 (already in package.json)

# - Phase 2-4 completed refactoring, tests still use custom runner

# - This plan migrates unit tests only (integration in 05-02)

@vitest.config.js
@tests/unit/models/Plan.test.js (example of current format - export functions + import.meta.url guards)

**Tech stack available:**

- Vitest 4.0.17 with native ES6 module support
- Node environment (no bundler required)
- happy-dom available for localStorage tests

**Migration pattern from research:**

- Replace `export function testX()` with `it('should x', () => { })`
- Replace `if (value !== expected) throw new Error()` with `expect(value).toBe(expected)`
- Remove `if (import.meta.url === ...)` execution guards
- Use describe() blocks for test organization
  </context>

<tasks>

<task type="auto">
  <name>Task 1: Create migrated Plan.test.js as template</name>
  <files>tests/unit/models/Plan.test.js</files>
  <action>
    Migrate tests/unit/models/Plan.test.js from custom runner to Vitest format:

    Before:
    ```javascript
    import { Plan } from '../../../src/core/models/Plan.js';

    export function testPlanCreation() {
      const plan = new Plan('Test Plan', 35, 65);
      if (plan.name !== 'Test Plan') {
        throw new Error('Expected plan name to be "Test Plan"');
      }
      // ... more throw Error assertions
      console.log('✓ testPlanCreation passed');
    }

    if (import.meta.url === `file://${process.argv[1]}`) {
      testPlanCreation();
    }
    ```

    After:
    ```javascript
    import { describe, it, expect } from 'vitest';
    import { Plan } from '../../../src/core/models/Plan.js';

    describe('Plan', () => {
      describe('creation', () => {
        it('should create plan with correct name', () => {
          const plan = new Plan('Test Plan', 35, 65);
          expect(plan.name).toBe('Test Plan');
        });

        it('should generate unique ID on creation', () => {
          const plan = new Plan('Test Plan', 35, 65);
          expect(plan.id).toBeDefined();
          expect(typeof plan.id).toBe('string');
        });

        it('should initialize with empty accounts array', () => {
          const plan = new Plan('Test Plan', 35, 65);
          expect(plan.accounts).toEqual([]);
          expect(plan.accounts.length).toBe(0);
        });
      });

      describe('addAccount', () => {
        it('should add account to plan', () => {
          const plan = new Plan('Test Plan', 35, 65);
          const account = { id: 'acc_test', name: 'Test Account', type: '401k', balance: 100000, annualContribution: 10000 };
          plan.addAccount(account);
          expect(plan.accounts).toHaveLength(1);
        });
      });
    });
    ```

    Use this pattern as template for all other unit test migrations.

  </action>
  <verify>File uses describe/it/expect, no import.meta.url guards, npm test passes for this file</verify>
  <done>Plan.test.js migrated to Vitest format, serves as template for other migrations</done>
</task>

<task type="auto">
  <name>Task 2: Migrate model tests (4 files)</name>
  <files>tests/unit/models/Account.test.js, tests/unit/models/Income.test.js, tests/unit/models/Expense.test.js</files>
  <action>
    Migrate remaining model tests using Plan.test.js as template:

    - tests/unit/models/Account.test.js
    - tests/unit/models/Income.test.js
    - tests/unit/models/Expense.test.js

    For each file:
    1. Add import: `import { describe, it, expect } from 'vitest';`
    2. Replace export function testX() with it('should x', () => { })
    3. Convert throw Error assertions to expect() assertions
    4. Wrap related tests in describe() blocks by feature/function
    5. Remove import.meta.url execution guard

    Common patterns:
    - `if (x !== y) throw Error` → `expect(x).toBe(y)`
    - `if (!x) throw Error` → `expect(x).toBeTruthy()`
    - `if (arr.length !== n) throw Error` → `expect(arr).toHaveLength(n)`

  </action>
  <verify>All 3 model test files use Vitest format, npm test passes for models/*</verify>
  <done>Model tests (Account, Income, Expense) migrated to Vitest format</done>
</task>

<task type="auto">
  <name>Task 3: Migrate core/rules tests (2 files)</name>
  <files>tests/unit/core/rules/BackdoorRothRule.test.js, tests/unit/core/rules/RuleRegistry.test.js</files>
  <action>
    Migrate rule tests using same pattern:

    - tests/unit/core/rules/BackdoorRothRule.test.js
    - tests/unit/core/rules/RuleRegistry.test.js

    Focus on:
    - Rule creation and configuration tests
    - Rule application logic tests
    - Edge cases and error conditions

    Group tests by rule method or behavior using describe().

  </action>
  <verify>Both rule test files use Vitest format, npm test passes for core/rules/*</verify>
  <done>Core rules tests migrated to Vitest format</done>
</task>

<task type="auto">
  <name>Task 4: Migrate storage test (1 file)</name>
  <files>tests/unit/storage/StorageManager.test.js</files>
  <action>
    Migrate tests/unit/storage/StorageManager.test.js:

    This file likely tests localStorage operations. For localStorage tests:
    - Keep Node environment (vitest.config.js default)
    - Use vi.stubGlobal for localStorage mock (from research Pattern 2)

    Example approach:
    ```javascript
    import { vi, describe, it, expect, beforeEach, afterEach } from 'vitest';

    const mockStorage = new Map();
    beforeEach(() => {
      vi.stubGlobal('localStorage', {
        getItem: vi.fn((key) => mockStorage.get(key) || null),
        setItem: vi.fn((key, value) => mockStorage.set(key, value)),
        removeItem: vi.fn((key) => mockStorage.delete(key)),
        clear: vi.fn(() => mockStorage.clear()),
      });
    });

    afterEach(() => {
      vi.unstubAllGlobals();
      mockStorage.clear();
    });
    ```

    Convert all throw Error assertions to expect() format.

  </action>
  <verify>StorageManager test uses Vitest format with mocked localStorage, npm test passes</verify>
  <done>StorageManager test migrated to Vitest format with proper localStorage mocking</done>
</task>

<task type="auto">
  <name>Task 5: Migrate calculation tests (9 files)</name>
  <files>tests/unit/calculations/*.test.js</files>
  <action>
    Migrate all 9 calculation unit tests:

    - tax.test.js (federal tax calculations)
    - tax-state.test.js (state tax calculations)
    - projection.test.js (projection calculations)
    - income.test.js (income calculations)
    - qcd.test.js (QCD calculations)
    - roth-conversions.test.js (Roth conversion calculations)
    - rmd.test.js (RMD calculations)
    - social-security.test.js (Social Security calculations)
    - tax-loss-harvesting.test.js (tax-loss harvesting)
    - withdrawal-strategies.test.js (withdrawal strategies)
    - monte-carlo.test.js (Monte Carlo simulations)

    Group by calculation function using describe():
    - describe('calculateX') for each calculation function
    - describe('edge cases') for boundary/edge condition tests
    - describe('integration with Y') for cross-cutting concerns

    These tests may have complex assertions - ensure all are converted to expect().

  </action>
  <verify>All 10 calculation test files use Vitest format, npm test passes for calculations/*</verify>
  <done>All calculation unit tests migrated to Vitest format</done>
</task>

<task type="auto">
  <name>Task 6: Migrate UI controller test (1 file)</name>
  <files>tests/unit/ui/AppController.test.js</files>
  <action>
    Migrate tests/unit/ui/AppController.test.js:

    This tests UI controller logic. May involve:
    - Event handler tests
    - State management tests
    - DOM interaction tests (if any)

    If DOM mocking needed:
    - Use vi.stubGlobal for document/window if in Node environment
    - Or update vitest.config.js to use happy-dom environment

    Convert all throw Error assertions to expect().

  </action>
  <verify>AppController test uses Vitest format, npm test passes for ui/*</verify>
  <done>UI controller test migrated to Vitest format</done>
</task>

<task type="auto">
  <name>Task 7: Run full unit test suite</name>
  <files>vitest.config.js</files>
  <action>
    Run full unit test suite to verify all migrations successful:

    ```bash
    npm test
    ```

    Expected output:
    - All 19 unit test files discovered and executed
    - No "0 tests found" or "no test files matched" errors
    - All tests passing (green checkmarks)
    - Test summary shows correct pass/fail counts

    If tests fail:
    - Check for remaining import.meta.url guards
    - Verify all expect() imports present
    - Check for syntax errors in converted files
    - Run single file: `npx vitest run tests/unit/models/Plan.test.js`

    Update vitest.config.js if needed (environment, include patterns).

  </action>
  <verify>npm test shows all unit tests passing (19 test files, expected pass count)</verify>
  <done>Full unit test suite passes with Vitest, all 19 files migrated successfully</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] All 19 unit test files use describe/it/expect format
- [ ] No import.meta.url execution guards remain in any test file
- [ ] `npm test` runs all unit tests successfully
- [ ] No test failures or errors in output
- [ ] All converted files pass `npm run lint` (existing errors only)
- [ ] Test execution time reasonable (< 30 seconds)
</verification>

<success_criteria>

- All unit tests migrated from custom runner to Vitest format
- No remaining throw Error assertions or import.meta.url guards
- All 19 unit test files discovered and passing
- npm test works without modifications
- Ready for 05-02-PLAN.md (integration test migration)
  </success_criteria>

<output>
After completion, create `.planning/phases/05-test-migration/05-01-SUMMARY.md`
</output>

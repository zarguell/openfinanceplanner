---
phase: 04-config-centralization
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/core/rules/MegaBackdoorRothRule.js
  - src/calculations/qcd.js
  - src/calculations/roth-conversions.js
  - config/limits.json
  - config/loader.js
autonomous: true
must_haves:
  truths:
    - "401k contribution limits are centralized in config/limits.json"
    - "QCD annual limit is centralized in config/limits.json"
    - "Source files import limits from config, not hardcoded values"
    - "Changing a limit in config updates all references automatically"
  artifacts:
    - path: "config/limits.json"
      provides: "Contribution limits and annual limits"
      contains: "401k limits, QCD limit, catch-up limits"
    - path: "config/loader.js"
      provides: "Centralized config loader"
      exports: ["getContributionLimit", "getQCDLimit"]
    - path: "src/core/rules/MegaBackdoorRothRule.js"
      provides: "Mega backdoor Roth strategy"
      contains: "import from config/loader.js"
  key_links:
    - from: "src/core/rules/MegaBackdoorRothRule.js"
      to: "config/limits.json"
      via: "getContributionLimit from loader.js"
    - from: "src/calculations/qcd.js"
      to: "config/limits.json"
      via: "getQCDLimit from loader.js"
---

<objective>
Extract retirement account contribution limits and annual limits to centralized configuration.

Purpose: Centralize hardcoded dollar amount limits (401k contributions, QCD limits) to make them easy to update and maintain consistency across the codebase.

Output: config/limits.json file with all contribution limits, config/loader.js with limit accessors, and updated source files importing from config.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/CONCERNS.md

# Prior phase context:
# Phase 2 successfully extracted tax brackets to config files using ES6 modules
# Phase 3 refactored UI controllers into focused modules
# This phase continues the config extraction pattern for non-tax constants

@src/core/rules/MegaBackdoorRothRule.js
@src/calculations/qcd.js
@src/calculations/roth-conversions.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create config/limits.json with all contribution limits</name>
  <files>config/limits.json</files>
  <action>
    Create config/limits.json with structure:

    ```json
    {
      "2024": {
        "401k": {
          "employeeDeferralLimit": 23000,
          "totalContributionLimit": 69000,
          "catchupLimit": 7500
        },
        "401k": {
          "employeeDeferralLimit": 23500,
          "totalContributionLimit": 76000,
          "catchupLimit": 7500
        },
        "ira": {
          "contributionLimit": 7000,
          "catchupLimit": 1000
        },
        "qcd": {
          "annualLimit": 100000
        }
      }
    }
    ```

    Include both 2024 and 2025 values to match tax bracket pattern from Phase 2.
    All values in dollars (not cents) for readability - conversion to cents happens in loader.
  </action>
  <verify>File exists with valid JSON structure, contains all limit types</verify>
  <done>config/limits.json created with 2024/2025 contribution limits</done>
</task>

<task type="auto">
  <name>Task 2: Create config/loader.js with limit accessor functions</name>
  <files>config/loader.js</files>
  <action>
    Create config/loader.js with synchronous ES6 imports (matching Phase 2 pattern):

    ```javascript
    import limitsData from './limits.json';

    export function getContributionLimit(accountType, year = 2025, includeCatchup = false) {
      const yearData = limitsData[year] || limitsData['2025'];
      const accountLimits = yearData[accountType];

      if (!accountLimits) {
        throw new Error(`Unknown account type: ${accountType}`);
      }

      let limit = accountLimits.employeeDeferralLimit || accountLimits.contributionLimit;

      if (includeCatchup && accountLimits.catchupLimit) {
        limit += accountLimits.catchupLimit;
      }

      return limit * 100; // Convert dollars to cents
    }

    export function getTotalContributionLimit(accountType, year = 2025) {
      const yearData = limitsData[year] || limitsData['2025'];
      const accountLimits = yearData[accountType];

      if (!accountLimits || !accountLimits.totalContributionLimit) {
        throw new Error(`Total limit not available for ${accountType}`);
      }

      return accountLimits.totalContributionLimit * 100;
    }

    export function getQCDLimit(year = 2025) {
      const yearData = limitsData[year] || limitsData['2025'];
      return yearData.qcd.annualLimit * 100;
    }
    ```

    Follow Phase 2's synchronous import pattern for backward compatibility.
  </action>
  <verify>File exists, exports all three functions, ES6 syntax is valid</verify>
  <done>config/loader.js created with limit accessor functions</done>
</task>

<task type="auto">
  <name>Task 3: Update MegaBackdoorRothRule to use config limits</name>
  <files>src/core/rules/MegaBackdoorRothRule.js</files>
  <action>
    1. Add import at top: `import { getContributionLimit, getTotalContributionLimit } from '../../config/loader.js';`

    2. Replace hardcoded defaults in constructor (lines 11-16):
       - `this.annualContribution = (config.annualContribution || 15000) * 100;` â†’ Keep (user-provided, not a constant)
       - `this.employeeDeferralLimit = config.employeeDeferralLimit || getContributionLimit('401k')`
       - `this.total401kLimit = config.total401kLimit || getTotalContributionLimit('401k')`

    3. Update line 172 hardcoded 69000:
       - `const totalLimit = total401kLimits[yearToIndex] || getTotalContributionLimit('401k')`

    Remove the multiplication by 100 since loader functions already return cents.
  </action>
  <verify>File imports from config/loader.js, no hardcoded dollar amounts remain</verify>
  <done>MegaBackdoorRothRule imports limits from config</done>
</task>

<task type="auto">
  <name>Task 4: Update QCD calculation to use config limit</name>
  <files>src/calculations/qcd.js</files>
  <action>
    1. Add import at top: `import { getQCDLimit } from '../../config/loader.js';`

    2. Replace hardcoded QCD_ANNUAL_LIMIT (line 7):
       - Before: `const QCD_ANNUAL_LIMIT = 100000 * 100;`
       - After: `const QCD_ANNUAL_LIMIT = getQCDLimit();`

    Remove the hardcoded constant entirely.
  </action>
  <verify>File imports getQCDLimit from config, hardcoded constant removed</verify>
  <done>QCD limit imported from config</done>
</task>

<task type="auto">
  <name>Task 5: Update roth-conversions.js example values</name>
  <files>src/calculations/roth-conversions.js</files>
  <action>
    Lines 220-221 contain hardcoded example values for demonstration:
    - `const bracketTop = 89450 * 100;`
    - `const taxableIncome = 100000 * 100;`

    These appear to be test/example values in a docstring or comment.
    If they're in actual code, replace with imports from limits config.
    If they're just examples in comments, leave them but add a comment that these are examples.
  </action>
  <verify>No actual code uses hardcoded dollar amounts (examples in comments are OK)</verify>
  <done>Example values documented as examples only</done>
</task>

</tasks>

<verification>
Before declaring plan complete:
- [ ] config/limits.json exists with valid JSON
- [ ] config/loader.js exists and exports all functions
- [ ] MegaBackdoorRothRule imports from config/loader.js
- [ ] qcd.js imports from config/loader.js
- [ ] No hardcoded contribution limits remain in business logic
- [ ] npm test passes (or custom test runner succeeds)
</verification>

<success_criteria>

- All contribution limits centralized in config/limits.json
- Centralized loader module provides access to all limits
- Source files import limits from config (no hardcoded values)
- Pattern consistent with Phase 2 tax bracket extraction
- All tests passing
  </success_criteria>

<output>
After completion, create `.planning/phases/04-config-centralization/04-01-SUMMARY.md`
</output>
